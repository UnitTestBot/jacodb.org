import JavaKotlinCodeBlock from "../../components/JavaKoltinCodeBlock";
import Examples from "../../components/examples";

# Basic usage

JacoDB API has two levels: the one representing in filesystem (bytecode and classes), and the one appearing at runtime
(types).

* bytecode and classes — represent data from `class` files: class with methods, fields, etc.
* types — represent types that can be nullable, parameterized, etc.

Both levels are connected to `JcClasspath`. You can't modify classes retrieved from pure bytecode.
types may be constructed manually by generic substitution.

## Get declared methods (example)

<JavaKotlinCodeBlock
    javaCode={Examples.getDeclaredMethods.java}
    kotlinCode={Examples.getDeclaredMethods.kotlin}
/>

Note: the `body` method returns `null` if the to-be-processed JAR-file is changed or removed. Class could be in
incomplete environment (i.e super class, interface, return type or parameter of method is not found in classpath)
then api will
throw `NoClassInClasspathException` at runtime.

## Watch for file system changes

The database can watch for file system changes in the background and refresh the JAR-files explicitly:

<JavaKotlinCodeBlock
    javaCode={Examples.watchFileSystem.java}
    kotlinCode={Examples.watchFileSystem.kotlin}
/>

## Get type information

**type** can be represented as one of

* primitives
* classes
* arrays
* bounded and unbounded wildcards

It represents runtime behavior according to parameter substitution in the given generic type:

<JavaKotlinCodeBlock
    javaCode={Examples.getTypeInformation.java}
    kotlinCode={Examples.getTypeInformation.kotlin}
/>

## Multithreading

The instances of `JcClassOrInterface`, `JcMethod`, and `JcClasspath` are thread-safe and immutable.

`JcClasspath` represents an independent snapshot of classes, which cannot be modified since it is created.
Removing or modifying library files does not affect `JcClasspath` instance structure. The `JcClasspath#close` method releases
all snapshots and cleans up the persisted data if some libraries are outdated.

<JavaKotlinCodeBlock
    javaCode={Examples.refreshDatabase.java}
    kotlinCode={Examples.refreshDatabase.kotlin}
/>

If there is a request for a `JcClasspath` instance containing the libraries, which haven't been indexed yet,
the indexing process is triggered and the new instance of the `JcClasspath` set is returned.

<JavaKotlinCodeBlock
    javaCode={Examples.autoProcessing.java}
    kotlinCode={Examples.autoProcessing.kotlin}
/>

`JacoDB` is thread-safe. If one requests `JcClasspath` instance while loading JAR-files from another thread,
`JcClasspath` can represent only a consistent state of the JAR-files being loaded. It is the completely loaded
JAR-file that appears in `JcClasspath`. Please note: there is no guarantee that all the JAR-files, submitted for loading, will be actually loaded.

<JavaKotlinCodeBlock
    javaCode={Examples.newThread.java}
    kotlinCode={Examples.newThread.kotlin}
/>

## Bytecode loading

Bytecode loading consists of two steps:

* retrieving information about the class names from the JAR-files or build directories
* reading **classes** bytecode from the JAR-files or build directories and processing it (persisting data, setting up `JcFeature` implementations, etc.)

`JacoDB` or `JcClasspath` instances are returned right after the first step is performed. You retrieve the final representation
of **classes** during the second step. It is possible that the `.class` files undergo changes at some moment between the first step
and the second, and **classes** representation is affected accordingly.